# simulation_test_2025_optimized.py
import pandas as pd
import numpy as np
from catboost import CatBoostRegressor
from sklearn.metrics import mean_absolute_error, mean_absolute_percentage_error
import warnings
warnings.filterwarnings('ignore')

# === КОНСТАНТЫ ===
MODEL_PATH = 'filtered_energy_model_2022_2024.cbm'
PROCESSED_DATA_FILE = 'corrected_energy_data.csv'  # или 'binary_calendar_energy_data.csv'
SIMULATION_RESULTS_PATH = 'simulation_results_optimized.pkl'

class EnergyConsumptionSimulator:
    def __init__(self):
        self.model = None
        self.feature_names = None
        self.results = {}
        
    def load_model_and_data(self):
        """Загрузка модели и данных"""
        print("Загрузка модели и данных...")
        
        try:
            self.model = CatBoostRegressor()
            self.model.load_model(MODEL_PATH)
            self.feature_names = self.model.feature_names_
            print(f"Модель загружена: {MODEL_PATH}")
            print(f"Используется {len(self.feature_names)} признаков")
        except Exception as e:
            print(f"Ошибка загрузки модели: {e}")
            return False
        
        try:
            self.df = pd.read_csv(PROCESSED_DATA_FILE)
            self.df['datetime'] = pd.to_datetime(self.df['datetime'])
            
            # Удаляем дубликаты datetime
            initial_count = len(self.df)
            self.df = self.df.drop_duplicates(subset=['datetime']).reset_index(drop=True)
            duplicates_removed = initial_count - len(self.df)
            if duplicates_removed > 0:
                print(f"Удалено дубликатов datetime: {duplicates_removed}")
            
            self.df = self.df.sort_values('datetime').reset_index(drop=True)
            print(f"Данные загружены: {len(self.df)} записей")
            print(f"Период данных: {self.df['datetime'].min()} - {self.df['datetime'].max()}")
            
        except Exception as e:
            print(f"Ошибка загрузки данных: {e}")
            return False
            
        return True
    
    def prepare_custom_test_data(self, start_date, end_date):
        """Подготовка тестовых данных для выбранного периода"""
        print(f"Подготовка данных для периода {start_date} - {end_date}")
        
        start_date = pd.to_datetime(start_date)
        end_date = pd.to_datetime(end_date)
        
        mask = (self.df['datetime'] >= start_date) & (self.df['datetime'] <= end_date)
        df_custom = self.df[mask].copy()
        
        if len(df_custom) == 0:
            print("Нет данных для выбранного периода")
            return None
        
        print(f"Данные за выбранный период: {len(df_custom)} записей")
        print(f"Период: {df_custom['datetime'].min()} - {df_custom['datetime'].max()}")
        
        # Проверяем наличие всех признаков
        missing_features = [f for f in self.feature_names if f not in df_custom.columns]
        if missing_features:
            print(f"Отсутствующие признаки: {missing_features}")
            for feature in missing_features:
                if feature in self.df.columns:
                    median_val = self.df[feature].median()
                    df_custom[feature] = median_val
                    print(f"   Заполнен {feature} медианой: {median_val:.2f}")
        
        return df_custom
    
    def get_daily_8am_points(self, df_test):
        """Получение точек в 8:00 утра для каждого дня"""
        # Фильтруем только точки в 8:00 утра
        df_8am = df_test[df_test['datetime'].dt.hour == 8].copy()
        
        # Убираем дубликаты по дате (оставляем только первую точку в 8:00 каждого дня)
        df_8am['date'] = df_8am['datetime'].dt.date
        df_8am = df_8am.drop_duplicates(subset=['date']).reset_index(drop=True)
        
        print(f"Найдено {len(df_8am)} точек в 8:00 утра")
        print(f"Диапазон: {df_8am['datetime'].min()} - {df_8am['datetime'].max()}")
        
        return df_8am
    
    def simulate_daily_forecasts(self, df_test, forecast_horizons=[24, 48, 72]):
        """Прогнозирование только в 8:00 утра для каждого дня"""
        print(f"Прогнозирование на {forecast_horizons} часов вперед")
        print(f"Всего точек для тестирования (в 8:00 утра): {len(df_test)}")
        
        all_results = []
        detailed_errors = []
        
        max_horizon = max(forecast_horizons)
        
        # Получаем точки в 8:00 утра
        df_8am = self.get_daily_8am_points(df_test)
        
        for i, row in df_8am.iterrows():
            start_date = row['datetime']
            start_idx = df_test[df_test['datetime'] == start_date].index[0]
            
            print(f"Обработка точки {i+1}/{len(df_8am)}: {start_date}")
            
            for horizon in forecast_horizons:
                end_idx = start_idx + horizon
                
                if end_idx >= len(df_test):
                    print(f"  Пропуск горизонта {horizon} часов - недостаточно данных")
                    continue
                
                forecast_results = self._recursive_forecast(df_test, start_idx, horizon)
                
                if forecast_results:
                    # Анализ ошибок по порогу 2.5%
                    error_analysis = self._analyze_errors_by_threshold(
                        forecast_results['actual_values'],
                        forecast_results['predictions'],
                        threshold=2.5
                    )
                    
                    all_results.append({
                        'start_date': start_date,
                        'start_index': start_idx,
                        'horizon_hours': horizon,
                        'horizon_days': horizon // 24,
                        **forecast_results,
                        **error_analysis
                    })
                    
                    # Сохраняем детальные ошибки для каждого часа
                    for hour_idx, (actual, pred, date) in enumerate(zip(
                        forecast_results['actual_values'],
                        forecast_results['predictions'],
                        forecast_results['dates']
                    )):
                        detailed_errors.append({
                            'start_date': start_date,
                            'forecast_date': date,
                            'horizon_days': horizon // 24,
                            'hour_ahead': hour_idx + 1,
                            'actual': actual,
                            'predicted': pred,
                            'absolute_error': abs(actual - pred),
                            'percentage_error': abs((actual - pred) / actual) * 100 if actual != 0 else 0,
                            'exceeds_2.5_percent': abs((actual - pred) / actual) * 100 > 2.5 if actual != 0 else False,
                            'month': date.month,
                            'month_name': date.strftime('%B'),
                            'day': date.date()
                        })
        
        results_df = pd.DataFrame(all_results)
        errors_df = pd.DataFrame(detailed_errors)
        
        print(f"Завершено: {len(results_df)} прогнозов, {len(errors_df)} отдельных предсказаний")
        
        return results_df, errors_df
    
    def _recursive_forecast(self, df_test, start_idx, horizon):
        """Рекурсивное прогнозирование на несколько шагов вперед"""
        try:
            predictions = []
            actual_values = []
            dates = []
            
            for step in range(horizon):
                current_idx = start_idx + step
                
                if current_idx >= len(df_test):
                    break
                
                current_features = df_test.iloc[current_idx][self.feature_names].values.reshape(1, -1)
                prediction = self.model.predict(current_features)[0]
                predictions.append(prediction)
                
                actual_value = df_test.iloc[current_idx]['consumption']
                actual_values.append(actual_value)
                dates.append(df_test.iloc[current_idx]['datetime'])
            
            if len(predictions) == 0:
                return None
            
            mae = mean_absolute_error(actual_values, predictions)
            mape = mean_absolute_percentage_error(actual_values, predictions) * 100
            
            return {
                'predictions': predictions,
                'actual_values': actual_values,
                'dates': dates,
                'mae': mae,
                'mape': mape,
                'data_points': len(predictions)
            }
            
        except Exception as e:
            print(f"Ошибка в рекурсивном прогнозировании: {e}")
            return None
    
    def _analyze_errors_by_threshold(self, actual_values, predictions, threshold=2.5):
        """Анализ ошибок относительно порогового значения"""
        errors = []
        exceeds_threshold = 0
        
        for actual, pred in zip(actual_values, predictions):
            if actual != 0:
                percentage_error = abs((actual - pred) / actual) * 100
                errors.append(percentage_error)
                if percentage_error > threshold:
                    exceeds_threshold += 1
            else:
                errors.append(0)
        
        total_points = len(actual_values)
        exceeds_percentage = (exceeds_threshold / total_points) * 100 if total_points > 0 else 0
        
        return {
            'errors_percentage': errors,
            'exceeds_threshold_count': exceeds_threshold,
            'exceeds_threshold_percentage': exceeds_percentage,
            'threshold': threshold
        }
    
    def analyze_simulation_results(self, results_df, errors_df):
        """Анализ результатов симуляции"""
        print("\nАнализ результатов симуляции")
        
        if len(results_df) == 0:
            print("Нет результатов для анализа")
            return
        
        # Группируем по горизонту прогнозирования
        horizon_stats = results_df.groupby('horizon_days').agg({
            'mae': ['mean', 'std', 'min', 'max'],
            'mape': ['mean', 'std', 'min', 'max'],
            'exceeds_threshold_percentage': 'mean',
            'data_points': 'count'
        }).round(3)
        
        print("Статистика по горизонтам прогнозирования:")
        print(horizon_stats)
        
        # Анализ превышения порога ошибки по месяцам
        monthly_analysis = errors_df.groupby(['month', 'month_name']).agg({
            'exceeds_2.5_percent': ['sum', 'mean', 'count']
        }).round(3)
        
        monthly_analysis.columns = ['exceeds_count', 'exceeds_ratio', 'total_points']
        monthly_analysis['exceeds_percentage'] = (monthly_analysis['exceeds_ratio'] * 100).round(2)
        
        print(f"\nАнализ превышения порога ошибки 2.5% по месяцам:")
        for (month, month_name), stats in monthly_analysis.iterrows():
            print(f"   {month_name}: {stats['exceeds_count']:.0f}/{stats['total_points']:.0f} "
                  f"({stats['exceeds_percentage']}%) прогнозов превысили порог")
        
        # Общая статистика
        overall_mae = results_df['mae'].mean()
        overall_mape = results_df['mape'].mean()
        overall_exceeds = errors_df['exceeds_2.5_percent'].mean() * 100
        
        print(f"\nОбщие метрики:")
        print(f"   Средний MAE: {overall_mae:.3f}")
        print(f"   Средний MAPE: {overall_mape:.2f}%")
        print(f"   Прогнозов с ошибкой > 2.5%: {overall_exceeds:.2f}%")
        print(f"   Всего прогнозов: {len(results_df)}")
        print(f"   Всего отдельных предсказаний: {len(errors_df)}")
        
        # Анализ по дням недели
        errors_df['day_of_week'] = errors_df['forecast_date'].dt.dayofweek
        errors_df['day_name'] = errors_df['forecast_date'].dt.day_name()
        
        daily_stats = errors_df.groupby(['day_of_week', 'day_name']).agg({
            'percentage_error': ['mean', 'count'],
            'exceeds_2.5_percent': 'mean'
        }).round(3)
        
        daily_stats.columns = ['mean_error', 'count', 'exceeds_ratio']
        daily_stats['exceeds_percentage'] = (daily_stats['exceeds_ratio'] * 100).round(2)
        
        print(f"\nАнализ по дням недели:")
        for (day_of_week, day_name), stats in daily_stats.iterrows():
            print(f"   {day_name}: ошибка {stats['mean_error']:.2f}%, >2.5%: {stats['exceeds_percentage']}%")
        
        # Сохраняем результаты
        self.results = {
            'simulation_results': results_df,
            'detailed_errors': errors_df,
            'horizon_stats': horizon_stats,
            'monthly_analysis': monthly_analysis,
            'daily_analysis': daily_stats,
            'overall_metrics': {
                'mae': overall_mae,
                'mape': overall_mape,
                'exceeds_threshold_percentage': overall_exceeds,
                'total_forecasts': len(results_df),
                'total_predictions': len(errors_df)
            }
        }
        
        return self.results
    
    def print_detailed_monthly_analysis(self, results_df, errors_df):
        """Детальный анализ результатов по месяцам"""
        print("\nДетальный анализ по месяцам")
        
        # Анализ по месяцам
        monthly_stats = errors_df.groupby(['month', 'month_name']).agg({
            'percentage_error': ['mean', 'std', 'median'],
            'exceeds_2.5_percent': 'mean',
            'actual': 'count'
        }).round(3)
        
        monthly_stats.columns = ['mean_error', 'std_error', 'median_error', 'exceeds_ratio', 'total_predictions']
        monthly_stats['exceeds_percentage'] = (monthly_stats['exceeds_ratio'] * 100).round(2)
        
        print("Детальная статистика по месяцам:")
        for (month, month_name), stats in monthly_stats.iterrows():
            print(f"   {month_name}:")
            print(f"      Средняя ошибка: {stats['mean_error']:.2f}%")
            print(f"      Медианная ошибка: {stats['median_error']:.2f}%")
            print(f"      Стандартное отклонение: {stats['std_error']:.2f}%")
            print(f"      Превысили порог 2.5%: {stats['exceeds_percentage']}%")
            print(f"      Всего прогнозов: {stats['total_predictions']}")
        
        # Лучшие и худшие месяцы
        monthly_stats_reset = monthly_stats.reset_index()
        
        if len(monthly_stats_reset) > 0:
            best_month_idx = monthly_stats_reset['mean_error'].idxmin()
            worst_month_idx = monthly_stats_reset['mean_error'].idxmax()
            
            best_month_row = monthly_stats_reset.loc[best_month_idx]
            worst_month_row = monthly_stats_reset.loc[worst_month_idx]
            
            print(f"\nЛучший месяц:")
            print(f"   {best_month_row['month_name']}: средняя ошибка {best_month_row['mean_error']:.2f}%, "
                  f">2.5%: {best_month_row['exceeds_percentage']}%")
            
            print(f"Худший месяц:")
            print(f"   {worst_month_row['month_name']}: средняя ошибка {worst_month_row['mean_error']:.2f}%, "
                  f">2.5%: {worst_month_row['exceeds_percentage']}%")
        else:
            print("\nНедостаточно данных для определения лучшего/худшего месяца")
        
        # Сезонный анализ
        print(f"\nСезонный анализ:")
        winter_months = ['December', 'January', 'February']
        spring_months = ['March', 'April', 'May']
        summer_months = ['June', 'July', 'August']
        fall_months = ['September', 'October', 'November']
        
        seasons = {
            'Зима': winter_months,
            'Весна': spring_months,
            'Лето': summer_months,
            'Осень': fall_months
        }
        
        for season_name, months in seasons.items():
            season_data = errors_df[errors_df['month_name'].isin(months)]
            if len(season_data) > 0:
                avg_error = season_data['percentage_error'].mean()
                exceeds_pct = season_data['exceeds_2.5_percent'].mean() * 100
                print(f"   {season_name}: ошибка {avg_error:.2f}%, >2.5%: {exceeds_pct:.1f}%")
    
    def run_custom_period_simulation(self, start_date, end_date, forecast_horizons=[24, 48, 72]):
        """Запуск симуляции для выбранного периода"""
        print("Запуск симуляции для выбранного периода")
        print(f"Период: {start_date} - {end_date}")
        print(f"Горизонты прогнозирования: {forecast_horizons} часов")
        
        # 1. Загрузка модели и данных
        if not self.load_model_and_data():
            return None
        
        # 2. Подготовка тестовых данных для выбранного периода
        df_custom = self.prepare_custom_test_data(start_date, end_date)
        if df_custom is None:
            return None
        
        # 3. Запуск оптимизированной симуляции (только 8:00 утра)
        results_df, errors_df = self.simulate_daily_forecasts(
            df_custom, 
            forecast_horizons=forecast_horizons
        )
        
        if len(results_df) == 0:
            print("Не удалось получить результаты симуляции")
            return None
        
        # 4. Анализ результатов
        self.analyze_simulation_results(results_df, errors_df)
        
        # 5. Детальный анализ по месяцам
        self.print_detailed_monthly_analysis(results_df, errors_df)
        
        # 6. Сохранение результатов
        import joblib
        joblib.dump(self.results, SIMULATION_RESULTS_PATH)
        print(f"\nРезультаты симуляции сохранены в {SIMULATION_RESULTS_PATH}")
        
        return self.results

def main():
    """Основная функция с выбором периода"""
    
    start_date = '2025-01-01'
    end_date = '2025-03-31'
    
    # Прогнозы на 1, 2 и 3 дня (24, 48, 72 часа)
    forecast_horizons = [24, 48, 72]
    
    print(f"\nНастройки симуляции:")
    print(f"   Период: {start_date} - {end_date}")
    print(f"   Горизонты: {forecast_horizons} часов (1, 2 и 3 дня)")
    
    # Создаем и запускаем симулятор
    simulator = EnergyConsumptionSimulator()
    results = simulator.run_custom_period_simulation(
        start_date=start_date,
        end_date=end_date,
        forecast_horizons=forecast_horizons
    )
    
    if results is not None:
        print("\nСимуляция успешно завершена!")
        
        overall_metrics = results['overall_metrics']
        print(f"Итоговые результаты для периода {start_date} - {end_date}:")
        print(f"   Средний MAE: {overall_metrics['mae']:.3f}")
        print(f"   Средний MAPE: {overall_metrics['mape']:.2f}%")
        print(f"   Прогнозов с ошибкой > 2.5%: {overall_metrics['exceeds_threshold_percentage']:.2f}%")
        print(f"   Всего выполнено прогнозов: {overall_metrics['total_forecasts']}")
        print(f"   Всего отдельных предсказаний: {overall_metrics['total_predictions']}")
        
        # Дополнительная статистика по горизонтам
        print(f"\nДетализация по горизонтам прогнозирования:")
        horizon_stats = results['horizon_stats']
        for horizon in [1, 2, 3]:
            if horizon in horizon_stats.index:
                stats = horizon_stats.loc[horizon]
                print(f"   {horizon} день:")
                print(f"      MAE: {stats[('mae', 'mean')]:.3f} ± {stats[('mae', 'std')]:.3f}")
                print(f"      MAPE: {stats[('mape', 'mean')]:.2f}% ± {stats[('mape', 'std')]:.2f}%")
                print(f"      Прогнозов: {stats[('data_points', 'count')]:.0f}")
        
        # Сохраняем статистику в CSV
        results['detailed_errors'].to_csv('detailed_errors_optimized.csv', index=False)
        results['simulation_results'].to_csv('forecast_results_optimized.csv', index=False)
        print(f"\nДетальные данные сохранены в CSV файлы")
        
    else:
        print("Симуляция завершилась с ошибками")

if __name__ == "__main__":
    main()
